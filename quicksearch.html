<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Cerberus Node Client Classes CerberusClient Global Global Source: index.js 'use strict' const request = require('request-micro') const urlJoin = require('url-join') const FormData = require('form-data') const packageData = require('./package.json') const { getAuthenticationHeaders } = require('./lib/sts') const globalHeaders = { 'X-Cerberus-Client': `CerberusNodeClient/${packageData.version}` } const cerberusVersion = 'v1' function log () { console.log.apply(console, ['cerberus-node'].concat(Array.prototype.slice.call(arguments))) } function noop () { } /** * Cerberus client with CRUD operations for secure data and files. * * @example * var CerberusClient = require('cerberus-node-client') * * var client = new CerberusClient({ * // string, The cerberus URL to use. * hostUrl: YOUR_CERBERUS_HOST, * * // boolean, defaults to false. When true will console.log many operations * debug: true, * * // This will be used as the cerberus X-Vault-Token if supplied * // OVERRIDDEN by process.env.CERBERUS_TOKEN * // If present, normal authentication with cerberus will be skipped * // You should normally only be using this in testing environments * // When developing locally, it is easier to use process.env.CERBERUS_TOKEN * token: 'Some_Auth_Token' * }) * * cerberusClient.getSecureData('path/to/my/secret').then(secureConfig =&gt; { * //do something with config * }) */ class CerberusClient { /** * @param {CerberusClientOptions} options The options for the Cerberus client. */ constructor (options) { if (!options || typeof options !== 'object') { throw new Error('options parameter is required') } // Copy so we can safely mutate let configuration = Object.assign({}, options) configuration.log = configuration.debug ? log : noop // Override context with env variables let envToken = getEnvironmentVariable(process.env.CERBERUS_TOKEN) if (envToken) { configuration.log('environment variable token found', envToken) configuration.token = envToken } // Validate configuration if (typeof configuration.hostUrl !== 'string') { throw new Error('options.hostUrl must be a URL string') } this._configuration = configuration } /** * Fetches secure data. * * @param path The path for the secure data * @param {function} [cb] callback, will be called with resolved data if present * @return {Promise&lt;object&gt;} A promise that when resolved supplies the secure data */ getSecureData (path, cb) { return doSecretAction(this._configuration, 'GET', path, undefined, cb) } /** * Writes secure data. * * @param path The path for the secure data * @param {function} [cb] callback, will be called when write is finished * @return {Promise&lt;object&gt;} A promise that will be resolved when the write is finished */ writeSecureData (path, data, cb) { return doSecretAction(this._configuration, 'POST', path, data, cb) } /** * Deletes secure data. * * @param path The path for the secure data * @param {function} [cb] callback, will be called when delete is finished * @return {Promise&lt;object&gt;} A promise that will be resolved when the delete is finished */ deleteSecureData (path, cb) { return doSecretAction(this._configuration, 'DELETE', path, undefined, cb) } /** * lists the keys under a secure data path. * * @param path The path or partial path * @param {function} [cb] callback, will be called when list is finished with the results * @return {Promise&lt;object&gt;} A promise that will be resolved when the list is finished supplying the results */ listSecureData (path, cb) { return doSecretAction(this._configuration, 'LIST', path, undefined, cb) } /** * lists the files under a path. * * @param path The path or partial path * @param {function} [cb] callback, will be called when list is finished with the results * @return {Promise&lt;object&gt;} A promise that will be resolved when the list is finished supplying the results */ listFile (path, cb) { return doFileAction(this._configuration, 'LIST', path, undefined, cb) } /** * Reads the contents of an uploaded file * * @param path The path the the uploaded file * @param {function} [cb] callback, will be called when the file contents have been fetched * @return {Promise&lt;object&gt;} A promise that will be resolved when the file contents have been fetched */ readFile (path, cb) { return doFileAction(this._configuration, 'GET', path, undefined, cb) } /** * Uploads a file to a given path * * @param path The path * @param {function} [cb] callback, will be called when the file contents have been uploaded * @return {Promise&lt;object&gt;} A promise that will be resolved when the file contents have been uploaded */ writeFile (path, data, cb) { return doFileAction(this._configuration, 'POST', path, data, cb) } /** * deletes an uploaded file * * @param path The path the the uploaded file * @param {function} [cb] callback, will be called when the file contents have been deleted * @return {Promise&lt;object&gt;} A promise that will be resolved when the file contents have been deleted */ deleteFile (path, cb) { return doFileAction(this._configuration, 'DELETE', keyPath, undefined, cb) } } /** * Performs an API action against the secret endpoint in Cerberus * * @private * @param context The Cerberus client configuration context * @param type The type of secret action * @param path The secure data path * @param body The post for writes * @param cb A call back to execute when finished * @return {Promise&lt;*&gt;} This method returns a promised that when resolved will supply the secure data. */ const doSecretAction = async (context, type, path, body, cb) =&gt; { context.log(`Starting ${type} request for ${path}`) const token = await getToken(context) const response = await executeCerberusRequest(context, { headers: Object.assign({}, globalHeaders, { 'X-Cerberus-Token': token }), method: type === 'LIST' ? 'GET' : type, url: urlJoin(context.hostUrl, cerberusVersion, 'secret', path) + (type === 'LIST' ? '?list=true' : '') }) if (cb) { response .then(result =&gt; cb(null, result)) .catch(err =&gt; cb(err)) } else { return response.data } } /** * Executes a request against the Cerberus API dealing with any error cases. * * @private * @param context The Cerberus client configuration context * @param requestConfig The request configuration to be executed * @return {Promise&lt;*&gt;} The response JSON from Cerberus */ const executeCerberusRequest = async (context, requestConfig) =&gt; { let response try { response = await request(Object.assign({}, requestConfig, { json: true })) } catch (error) { context.log('There was an error executing a call to Cerberus.\\nmsg: \\'' + error.message + '\\'') } if (!(response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300)) { if (response.headers['content-type'].startsWith('application/json')) { throw new Error(formatCerberusError(response.data.errors)) } else { throw new Error('Cerberus returned a non success response that wasn\\'t ' + 'JSON, this is likely due to being blocked by the WAF') } } return response.data } /** * Upload, delete, read, and list files on Cerberus. * * @private * @param {object} context The request context * @param {string} type - The HTTP method (with the exception of 'LIST') to use as outlined in https://github.com/Nike-Inc/cerberus-management-service/blob/master/API.md * @param {string} filePath - The path of the file * @param {object} fileBuffer - Buffer of the file to upload * @param {function} cb - Callback * @returns {Promise&lt;object&gt;} Buffer if read file and Cerberus response otherwise */ const doFileAction = async (context, type, filePath, fileBuffer, cb) =&gt; { context.log(`Starting ${type} file request for ${filePath}`) const token = await getToken(context) let form if (fileBuffer) { form = new FormData({}) form.append('file-content', fileBuffer, {filename: filePath.match(/([^\\/]*)\\/*$/)[1]}) } const data = await executeCerberusRequest({ method: type === 'LIST' ? 'GET' : type, url: urlJoin(context.hostUrl, cerberusVersion, type === 'LIST' ? 'secure-files' : 'secure-file', filePath), headers: Object.assign({}, globalHeaders, {'X-Vault-Token': token}, type === 'POST' ? form.getHeaders() : undefined), body: form, json: type === 'LIST' || type === 'DELETE' }) if (cb) { data .then(result =&gt; cb(null, result)) .catch(err =&gt; cb(err)) } else { return data } } /** * Fetches a token either from a local env var or attempts to authenticate with Cerberus via the STS authentication endpoint. * * @private * @return {Promise&lt;string&gt;} when the promise is resolved the Cerberus auth token string is supplied. */ const getToken = async (context) =&gt; { // tokenExpiresAt in secs, Date.now in ms if (context.tokenExpiresAt &amp;&amp; (context.tokenExpiresAt &lt;= (Date.now() / 1000))) { context.tokenExpiresAt = null context.token = null } // Already has token if (context.token) { context.log('returning stored token') return context.token } let authResponse try { const authHeaders = await getAuthenticationHeaders(context.region ? context.region : 'us-west-2'); authResponse = await executeCerberusRequest(context, { method: 'POST', url: urlJoin(context.hostUrl, 'v2/auth/sts-identity'), headers: Object.assign({}, globalHeaders, authHeaders) }) } catch (error) { throw new Error('There was an issue trying to authenticate with Cerberus using the STS auth endpoint\\nmsg: \\'' + error.message + '\\'') } // Expire 60 seconds before lease is up, to account for latency context.tokenExpiresAt = (Date.now() / 1000) + authResponse['lease_duration'] - 60 // token TTL in secs, Date.now in ms context.token = authResponse['client_token'] return context.token } /** * Gets the set value or undefined * * @private * @param value The value under question * @return {String|undefined} Returns the string of the value or undefined */ function getEnvironmentVariable (value) { return value &amp;&amp; value !== 'undefined' &amp;&amp; value !== undefined &amp;&amp; value !== null ? value : undefined } /** * Formats a Backstopper API error into a serialized string * * @private * @param errors The error response from Cerberus * @return {string} The serialized error */ const formatCerberusError = (errors) =&gt; { return errors instanceof Array ? errors.map(e =&gt; e.message || e).join(', ') : JSON.stringify(errors) } /** * Options for creating a {@link CerberusClient} * @interface CerberusClientOptions * @typedef CerberusClientOptions * @type {Object} * @property {string} hostUrl required base url for the Cerberus API. * @property {boolean} [debug] If set to true additional logging occurs. */ module.exports = CerberusClient × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Dec 19th 2018 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Cerberus Node Client Classes CerberusClient Global Global Global Type Definitions CerberusClientOptions Options for creating a CerberusClient Type: Object Properties: Name Type Argument Description hostUrl string required base url for the Cerberus API. debug boolean &lt;optional&gt; If set to true additional logging occurs. Source: index.js, line 315 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Dec 19th 2018 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Cerberus Node Client Classes CerberusClient Global Global Classes Classes CerberusClient × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Dec 19th 2018 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Cerberus Node Client Classes CerberusClient Global Global Cerberus Node ClientThis is a node client for interacting with a Cerberus backend. It can be used in Amazon EC2 instances and Amazon Lambdas. To learn more about Cerberus, please visit the Cerberus website. Installationnpm install --save cerberus-node-clientUsageSee the CerberusClient class on the the docs site AuthenticationThe cerberus client uses the AWS SDK Credentials provider chain to load AWS IAM credentials and authenticates with Cerberus via the sts auth endpointThis client will work in any environment that has access to AWS Credentials. Cerberus will attempt to authenticate one its first call. The authentication result will be stored and reused. If the token has expired on a subsequent call, authentication will be repeated with the original configuration. You should not have to worry about authentication or token expiration; just use the client. A Note about Lambdas and CerberusWhile this client supports any env with IAM credentials, generally it does NOT make sense to store Lambda secrets in Cerberus for two reasons: Cerberus cannt support the scale that lambdas may need, e.g. thousands of requests per second Lambdas will not want the extra latency needed to authenticate and read from Cerberus A better solution for Lambda secrets is using the encrypted environmental variablesfeature provided by AWS. Another option is to store Lambda secrets in Cerberus but only read them at Lambda deploy time, then storing them as encryptedenvironmental variables, to avoid the extra Cerberus runtime latency. LicenseCerberus Management Service is released under the Apache License, Version 2.0 × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Dec 19th 2018 using the DocStrap template. "},"CerberusClient.html":{"id":"CerberusClient.html","title":"Class: CerberusClient","body":" Cerberus Node Client Classes CerberusClient Global Global Class: CerberusClient CerberusClient Cerberus client with CRUD operations for secure data and files. new CerberusClient(options) Parameters: Name Type Description options CerberusClientOptions The options for the Cerberus client. Source: index.js, line 43 Example var CerberusClient = require('cerberus-node-client') var client = new CerberusClient({ // string, The cerberus URL to use. hostUrl: YOUR_CERBERUS_HOST, // boolean, defaults to false. When true will console.log many operations debug: true, // This will be used as the cerberus X-Vault-Token if supplied // OVERRIDDEN by process.env.CERBERUS_TOKEN // If present, normal authentication with cerberus will be skipped // You should normally only be using this in testing environments // When developing locally, it is easier to use process.env.CERBERUS_TOKEN token: 'Some_Auth_Token' }) cerberusClient.getSecureData('path/to/my/secret').then(secureConfig =&gt; { //do something with config }) Methods deleteFile(path [, cb]) deletes an uploaded file Parameters: Name Type Argument Description path The path the the uploaded file cb function &lt;optional&gt; callback, will be called when the file contents have been deleted Source: index.js, line 155 Returns: A promise that will be resolved when the file contents have been deleted Type Promise.&lt;object&gt; deleteSecureData(path [, cb]) Deletes secure data. Parameters: Name Type Argument Description path The path for the secure data cb function &lt;optional&gt; callback, will be called when delete is finished Source: index.js, line 100 Returns: A promise that will be resolved when the delete is finished Type Promise.&lt;object&gt; getSecureData(path [, cb]) Fetches secure data. Parameters: Name Type Argument Description path The path for the secure data cb function &lt;optional&gt; callback, will be called with resolved data if present Source: index.js, line 78 Returns: A promise that when resolved supplies the secure data Type Promise.&lt;object&gt; listFile(path [, cb]) lists the files under a path. Parameters: Name Type Argument Description path The path or partial path cb function &lt;optional&gt; callback, will be called when list is finished with the results Source: index.js, line 122 Returns: A promise that will be resolved when the list is finished supplying the results Type Promise.&lt;object&gt; listSecureData(path [, cb]) lists the keys under a secure data path. Parameters: Name Type Argument Description path The path or partial path cb function &lt;optional&gt; callback, will be called when list is finished with the results Source: index.js, line 111 Returns: A promise that will be resolved when the list is finished supplying the results Type Promise.&lt;object&gt; readFile(path [, cb]) Reads the contents of an uploaded file Parameters: Name Type Argument Description path The path the the uploaded file cb function &lt;optional&gt; callback, will be called when the file contents have been fetched Source: index.js, line 133 Returns: A promise that will be resolved when the file contents have been fetched Type Promise.&lt;object&gt; writeFile(path [, cb]) Uploads a file to a given path Parameters: Name Type Argument Description path The path cb function &lt;optional&gt; callback, will be called when the file contents have been uploaded Source: index.js, line 144 Returns: A promise that will be resolved when the file contents have been uploaded Type Promise.&lt;object&gt; writeSecureData(path [, cb]) Writes secure data. Parameters: Name Type Argument Description path The path for the secure data cb function &lt;optional&gt; callback, will be called when write is finished Source: index.js, line 89 Returns: A promise that will be resolved when the write is finished Type Promise.&lt;object&gt; × Search results Close Documentation generated by JSDoc 3.5.5 on Wed Dec 19th 2018 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
