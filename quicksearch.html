<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Cerberus Node Client Classes CerberusClient Global Global Source: index.js 'use strict' const request = require('request-micro') const urlJoin = require('url-join') const FormData = require('form-data') const packageData = require('./package.json') const { getAuthenticationHeaders } = require('./lib/sts') const { log, noop } = require('./lib/log') const globalHeaders = { 'X-Cerberus-Client': `CerberusNodeClient/${packageData.version}` } const cerberusVersion = 'v1' /** * Options for creating a {@link CerberusClient} * @interface CerberusClientOptions * @typedef CerberusClientOptions * @type {object} * @property {string} hostUrl required base url for the Cerberus API. * @property {string} [region] region to sign sts auth request for, defaults to us-west-2 * @property {boolean} [debug] If set to true additional logging occurs. */ /** * @interface ListKeyResult * @typedef ListKeyResult * @type {object} * @property {array&lt;string&gt;} keys */ /** * @interface ListFileResult * @typedef ListFileResult * @type {object} * @property {boolean} has_next If the result requires pagination * @property {string} next_offset The offset to use for the next page * @property {number} limit The limit that was used for the results * @property {number} offset The offset of the results * @property {number} file_count_in_result Number of files in result * @property {number} total_file_count Number of total files under path * @property {array&lt;SecureFileSummaries&gt;} secure_file_summaries */ /** * @interface SecureFileSummaries * @typedef SecureFileSummaries * @type {object} * @property {string} sdbox_id The SDB id * @property {string} path The path for the file * @property {number} size_in_bytes The size in bytes of the file * @property {string} name The name of the file * @property {string} created_by Who originally uploaded the file * @property {string} created_ts ISO 8061 String of when the file was originally uploaded * @property {string} last_updated_by Who last updated the file * @property {string} last_updated_ts ISO 8061 String of when the file was last updated */ /** * Cerberus client with CRUD operations for secure data and files. * * @example * var CerberusClient = require('cerberus-node-client') * * var client = new CerberusClient({ * // string, The cerberus URL to use. * hostUrl: YOUR_CERBERUS_HOST, * * // boolean, defaults to false. When true will console.log many operations * debug: true, * * // This will be used as the cerberus X-Vault-Token if supplied * // OVERRIDDEN by process.env.CERBERUS_TOKEN * // If present, normal authentication with cerberus will be skipped * // You should normally only be using this in testing environments * // When developing locally, it is easier to use process.env.CERBERUS_TOKEN * token: 'Some_Auth_Token' * }) * * cerberusClient.getSecureData('path/to/my/secret').then(secureConfig =&gt; { * //do something with config * }) */ class CerberusClient { /** * @param {CerberusClientOptions} options The options for the Cerberus client. */ constructor (options) { if (!options || typeof options !== 'object') { throw new Error('options parameter is required') } this._log = options.debug ? log : noop // Override context with env variables let envToken = getEnvironmentVariable(process.env.CERBERUS_TOKEN) if (envToken) { this._log('environment variable token found', envToken) this._token = envToken } // Validate configuration if (typeof options.hostUrl !== 'string') { throw new Error('options.hostUrl must be a URL string') } this._hostUrl = options.hostUrl this._region = options.region ? options.region : 'us-west-2' } /** * Fetches secure data. * * @param {string} path The path for the secure data * @return {Promise&lt;object&gt;} A promise that when resolved supplies the secure data */ getSecureData (path) { return this._doSecretAction('GET', path, undefined) } /** * Writes secure data. * * @param {string} path The path for the secure data * @param {object} data The secure data * @return {Promise&lt;undefined&gt;} A promise that will be resolved when the write is finished */ writeSecureData (path, data) { return this._doSecretAction('POST', path, data) } /** * Deletes secure data. * * @param {string} path The path for the secure data * @return {Promise&lt;object&gt;} A promise that will be resolved when the delete is finished */ deleteSecureData (path) { return this._doSecretAction('DELETE', path, undefined) } /** * lists the keys under a secure data path. * * If no keys are present {ListKeyResult} will have an empty array. * * @param {string} path The path or partial path * @return {Promise&lt;ListKeyResult&gt;} A promise that will be resolved when the list is finished supplying the results */ async listPathsForSecureData (path) { let res try { res = await this._doSecretAction('LIST', path, undefined) } catch (e) { // If no keys under a partial path can be found the API returns a 404, lets convert that to set of empty keys if (e.message.includes('status code: 404')) { res = {keys: []} } else { throw e } } return res } /** * lists the files under a path. * * @param {string} path The path or partial path * @return {Promise&lt;ListFileResult&gt;} A promise that will be resolved when the list is finished supplying the {ListFileResult} */ listFile (path) { return this._doFileAction('LIST', path, undefined) } /** * Reads the contents of an uploaded file * * @param {string} path The path the the uploaded file * @return {Promise&lt;Buffer|string&gt;} A promise that will be resolved when the file contents have been fetched */ readFile (path) { return this._doFileAction('GET', path, undefined) } /** * Uploads a file to a given path * * @param {string} path The path * @param {string|Buffer} data The file buffer or string * @return {Promise&lt;object&gt;} A promise that will be resolved when the file contents have been uploaded */ writeFile (path, data) { return this._doFileAction('POST', path, data) } /** * deletes an uploaded file * * @param {string} path The path the the uploaded file * @return {Promise&lt;object&gt;} A promise that will be resolved when the file contents have been deleted */ deleteFile (path) { return this._doFileAction('DELETE', path, undefined) } /** * Performs an API action against the secret endpoint in Cerberus * * @param type The type of secret action * @param {string} path The secure data path * @param body The post for writes * @return {Promise&lt;*&gt;} This method returns a promised that when resolved will supply the secure data. * @private */ async _doSecretAction (type, path, body) { this._log(`Starting ${type} request for ${path}`) const token = await this._getToken() const response = await this._executeCerberusRequest({ headers: Object.assign({}, globalHeaders, { 'X-Cerberus-Token': token }), method: type === 'LIST' ? 'GET' : type, url: urlJoin(this._hostUrl, cerberusVersion, 'secret', path) + (type === 'LIST' ? '?list=true' : ''), body: body }) return response ? response.data : undefined } /** * Executes a request against the Cerberus API dealing with any error cases. * * @param requestConfig The request configuration to be executed * @return {Promise&lt;*&gt;} The response body from Cerberus * @private */ async _executeCerberusRequest (requestConfig) { let response try { response = await this._executeRequest(Object.assign({}, { json: true }, requestConfig)) } catch (error) { const msg = 'There was an error executing a call to Cerberus.\\nmsg: \\'' + error.message + '\\'' this._log(msg) throw new Error(msg) } if (!(response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300)) { if (response.headers['content-type'].startsWith('application/json')) { throw new Error(`Cerberus returned an error, when executing a call.\\nstatus code: ${response.statusCode}\\nmsg: ${JSON.stringify(response.data)}`) } else { throw new Error('Cerberus returned a non-success response that wasn\\'t JSON' + ', this is likely due to being blocked by the WAF') } } return response.data } // noinspection JSMethodCanBeStatic /** * Uses the micro request library to execute the request * @param requestConfig * @return {promise&lt;*&gt;} * @private */ _executeRequest (requestConfig) { return request(requestConfig) } /** * Upload, delete, read, and list files on Cerberus. * * @param {string} type - The HTTP method (with the exception of 'LIST') to use as outlined in https://github.com/Nike-Inc/cerberus-management-service/blob/master/API.md * @param {string} filePath - The path of the file * @param {string|Buffer} fileBuffer - Buffer of the file to upload * @returns {Promise&lt;object&gt;} Buffer if read file and Cerberus response otherwise * @private */ async _doFileAction (type, filePath, fileBuffer) { this._log(`Starting ${type} file request for ${filePath}`) const token = await this._getToken() let form if (fileBuffer) { form = new FormData({}) form.append('file-content', fileBuffer, {filename: filePath.match(/([^\\/]*)\\/*$/)[1]}) } const data = await this._executeCerberusRequest({ method: type === 'LIST' ? 'GET' : type, url: urlJoin(this._hostUrl, cerberusVersion, type === 'LIST' ? 'secure-files' : 'secure-file', filePath), headers: Object.assign({}, globalHeaders, {'X-Cerberus-Token': token}, type === 'POST' ? form.getHeaders() : undefined), body: form, json: type === 'LIST' || type === 'DELETE' }) return data } /** * Fetches a token either from a local env var or attempts to authenticate with Cerberus via the STS authentication endpoint. * * @return {Promise&lt;string&gt;} when the promise is resolved the Cerberus auth token string is supplied. * @private */ async _getToken () { // tokenExpiresAt in secs, Date.now in ms if (this._tokenExpiresAt &amp;&amp; (this._tokenExpiresAt &lt;= (Date.now() / 1000))) { this._tokenExpiresAt = null this._token = null } // Already has token if (this._token) { this._log('returning stored token') return this._token } let authResponse try { const authHeaders = await getAuthenticationHeaders(this._region) authResponse = await this._executeCerberusRequest({ method: 'POST', url: urlJoin(this._hostUrl, 'v2/auth/sts-identity'), headers: Object.assign({}, globalHeaders, authHeaders) }) } catch (error) { throw new Error('There was an issue trying to authenticate with Cerberus using the STS auth endpoint\\nmsg: \\'' + error.message + '\\'') } // Expire 60 seconds before lease is up, to account for latency this._tokenExpiresAt = (Date.now() / 1000) + authResponse['lease_duration'] - 60 // token TTL in secs, Date.now in ms this._token = authResponse['client_token'] return this._token } } /** * Gets the set value or undefined * * @param value The value under question * @return {String|undefined} Returns the string of the value or undefined * @private */ const getEnvironmentVariable = (value) =&gt; { return value &amp;&amp; value !== 'undefined' &amp;&amp; value !== undefined &amp;&amp; value !== null ? value : undefined } module.exports = CerberusClient × Search results Close Documentation generated by JSDoc 3.5.5 on Fri Dec 21st 2018 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Cerberus Node Client Classes CerberusClient Global Global Global Type Definitions CerberusClientOptions Options for creating a CerberusClient Type: object Properties: Name Type Argument Description hostUrl string required base url for the Cerberus API. region string &lt;optional&gt; region to sign sts auth request for, defaults to us-west-2 debug boolean &lt;optional&gt; If set to true additional logging occurs. Source: index.js, line 16 ListFileResult Type: object Properties: Name Type Description has_next boolean If the result requires pagination next_offset string The offset to use for the next page limit number The limit that was used for the results offset number The offset of the results file_count_in_result number Number of files in result total_file_count number Number of total files under path secure_file_summaries array.&lt;SecureFileSummaries&gt; Source: index.js, line 33 ListKeyResult Type: object Properties: Name Type Description keys array.&lt;string&gt; Source: index.js, line 26 SecureFileSummaries Type: object Properties: Name Type Description sdbox_id string The SDB id path string The path for the file size_in_bytes number The size in bytes of the file name string The name of the file created_by string Who originally uploaded the file created_ts string ISO 8061 String of when the file was originally uploaded last_updated_by string Who last updated the file last_updated_ts string ISO 8061 String of when the file was last updated Source: index.js, line 46 × Search results Close Documentation generated by JSDoc 3.5.5 on Fri Dec 21st 2018 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Cerberus Node Client Classes CerberusClient Global Global Classes Classes CerberusClient × Search results Close Documentation generated by JSDoc 3.5.5 on Fri Dec 21st 2018 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Cerberus Node Client Classes CerberusClient Global Global Cerberus Node ClientThis is a node client for interacting with a Cerberus backend. It can be used in any environment that has AWS credentials available. To learn more about Cerberus, please visit the Cerberus website. This library is compatible with node 8.x +, for previous versions of Node use the 1.x versions of the client Installationnpm install --save cerberus-node-clientUsageSee the CerberusClient class on the the docs site AuthenticationThe cerberus client uses the AWS SDK Credentials provider chain to load AWS IAM credentials and authenticates with Cerberus via the sts auth endpointThis client will work in any environment that has access to AWS Credentials. Cerberus will attempt to authenticate one its first call. The authentication result will be stored and reused. If the token has expired on a subsequent call, authentication will be repeated with the original configuration. You should not have to worry about authentication or token expiration; just use the client. A Note about Lambdas and CerberusWhile this client supports any env with IAM credentials, generally it does NOT make sense to store Lambda secrets in Cerberus for two reasons: Cerberus can't support the scale that lambdas may need, e.g. thousands of requests per second Lambdas will not want the extra latency needed to authenticate and read from Cerberus A better solution for Lambda secrets is using the encrypted environmental variablesfeature provided by AWS. Another option is to store Lambda secrets in Cerberus but only read them at Lambda deploy time, then storing them as encryptedenvironmental variables, to avoid the extra Cerberus runtime latency. LicenseCerberus Management Service is released under the Apache License, Version 2.0 × Search results Close Documentation generated by JSDoc 3.5.5 on Fri Dec 21st 2018 using the DocStrap template. "},"CerberusClient.html":{"id":"CerberusClient.html","title":"Class: CerberusClient","body":" Cerberus Node Client Classes CerberusClient Global Global Class: CerberusClient CerberusClient Cerberus client with CRUD operations for secure data and files. new CerberusClient(options) Parameters: Name Type Description options CerberusClientOptions The options for the Cerberus client. Source: index.js, line 85 Example var CerberusClient = require('cerberus-node-client') var client = new CerberusClient({ // string, The cerberus URL to use. hostUrl: YOUR_CERBERUS_HOST, // boolean, defaults to false. When true will console.log many operations debug: true, // This will be used as the cerberus X-Vault-Token if supplied // OVERRIDDEN by process.env.CERBERUS_TOKEN // If present, normal authentication with cerberus will be skipped // You should normally only be using this in testing environments // When developing locally, it is easier to use process.env.CERBERUS_TOKEN token: 'Some_Auth_Token' }) cerberusClient.getSecureData('path/to/my/secret').then(secureConfig =&gt; { //do something with config }) Methods deleteFile(path) deletes an uploaded file Parameters: Name Type Description path string The path the the uploaded file Source: index.js, line 203 Returns: A promise that will be resolved when the file contents have been deleted Type Promise.&lt;object&gt; deleteSecureData(path) Deletes secure data. Parameters: Name Type Description path string The path for the secure data Source: index.js, line 139 Returns: A promise that will be resolved when the delete is finished Type Promise.&lt;object&gt; getSecureData(path) Fetches secure data. Parameters: Name Type Description path string The path for the secure data Source: index.js, line 118 Returns: A promise that when resolved supplies the secure data Type Promise.&lt;object&gt; listFile(path) lists the files under a path. Parameters: Name Type Description path string The path or partial path Source: index.js, line 172 Returns: A promise that will be resolved when the list is finished supplying the {ListFileResult} Type Promise.&lt;ListFileResult&gt; &lt;async&gt; listPathsForSecureData(path) lists the keys under a secure data path. If no keys are present {ListKeyResult} will have an empty array. Parameters: Name Type Description path string The path or partial path Source: index.js, line 151 Returns: A promise that will be resolved when the list is finished supplying the results Type Promise.&lt;ListKeyResult&gt; readFile(path) Reads the contents of an uploaded file Parameters: Name Type Description path string The path the the uploaded file Source: index.js, line 182 Returns: A promise that will be resolved when the file contents have been fetched Type Promise.&lt;(Buffer|string)&gt; writeFile(path, data) Uploads a file to a given path Parameters: Name Type Description path string The path data string | Buffer The file buffer or string Source: index.js, line 193 Returns: A promise that will be resolved when the file contents have been uploaded Type Promise.&lt;object&gt; writeSecureData(path, data) Writes secure data. Parameters: Name Type Description path string The path for the secure data data object The secure data Source: index.js, line 129 Returns: A promise that will be resolved when the write is finished Type Promise.&lt;undefined&gt; × Search results Close Documentation generated by JSDoc 3.5.5 on Fri Dec 21st 2018 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
